# -*- coding: utf-8 -*-
"""AED2-ShortestWay_n_AlgorithmicComplexity

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1P3Q0SCKvf_MtvntMhrL31yYDgoP0s1ep

1) Implementar em Python o algoritmo do caminho mais curto (Algoritmo de Dijkstra). Implementar pelo menos 5 testes (pytest) validando sua implementação com uma função similar já feita no Networkx. (4,00 pontos)
"""

pip install pytest networkx # Instalação das bibliotecas necessárias



import heapq
import networkx as nx
import pytest

def dijkstra(graph, start):
    # Inicialização
    distances = {node: float('infinity') for node in graph}
    distances[start] = 0
    priority_queue = [(0, start)]

    while priority_queue:
        current_distance, current_node = heapq.heappop(priority_queue)

        # Verifica se a distância atual é menor do que a armazenada
        if current_distance > distances[current_node]:
            continue

        # Atualiza as distâncias para os vizinhos do nó atual
        for neighbor, weight in graph[current_node].items():
            distance = current_distance + weight
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(priority_queue, (distance, neighbor))

    return distances

# Função de teste para verificar se a implementação funciona corretamente
def test_dijkstra():
    # Teste 1
    grafo_1 = {
        'A': {'B': 1, 'C': 4},
        'B': {'A': 1, 'C': 2, 'D': 5},
        'C': {'A': 4, 'B': 2, 'D': 1},
        'D': {'B': 5, 'C': 1}
    }
    resultado_custom_1 = dijkstra(grafo_1, 'A')
    nx_grafo_1 = nx.Graph(grafo_1)
    resultado_nx_1 = nx.single_source_dijkstra_path_length(nx_grafo_1, 'A')
    assert resultado_custom_1 == resultado_nx_1
    print("Teste 1 - Resultado Customizado:", resultado_custom_1)
    print("Teste 1 - Resultado Networkx:", resultado_nx_1)

    # Teste 2
    grafo_2 = {
        'A': {'B': 2, 'C': 1},
        'B': {'A': 2, 'C': 3, 'D': 4},
        'C': {'A': 1, 'B': 3, 'D': 2},
        'D': {'B': 4, 'C': 2}
    }
    resultado_custom_2 = dijkstra(grafo_2, 'A')
    nx_grafo_2 = nx.Graph(grafo_2)
    resultado_nx_2 = nx.single_source_dijkstra_path_length(nx_grafo_2, 'A')
    assert resultado_custom_2 == resultado_nx_2
    print("Teste 2 - Resultado Customizado:", resultado_custom_2)
    print("Teste 2 - Resultado Networkx:", resultado_nx_2)

    # Teste 3
    grafo_3 = {
        'A': {'B': 3, 'C': 2, 'D': 5},
        'B': {'A': 3, 'C': 4, 'D': 2},
        'C': {'A': 2, 'B': 4, 'D': 1},
        'D': {'A': 5, 'B': 2, 'C': 1}
    }
    resultado_custom_3 = dijkstra(grafo_3, 'A')
    nx_grafo_3 = nx.Graph(grafo_3)
    resultado_nx_3 = nx.single_source_dijkstra_path_length(nx_grafo_3, 'A')
    assert resultado_custom_3 == resultado_nx_3
    print("Teste 3 - Resultado Customizado:", resultado_custom_3)
    print("Teste 3 - Resultado Networkx:", resultado_nx_3)

    # Teste 4
    grafo_4 = {
        'A': {'B': 1, 'C': 2},
        'B': {'A': 1, 'C': 3, 'D': 4},
        'C': {'A': 2, 'B': 3, 'D': 1},
        'D': {'B': 4, 'C': 1}
    }
    resultado_custom_4 = dijkstra(grafo_4, 'A')
    nx_grafo_4 = nx.Graph(grafo_4)
    resultado_nx_4 = nx.single_source_dijkstra_path_length(nx_grafo_4, 'A')
    assert resultado_custom_4 == resultado_nx_4
    print("Teste 4 - Resultado Customizado:", resultado_custom_4)
    print("Teste 4 - Resultado Networkx:", resultado_nx_4)

    # Teste 5
    grafo_5 = {
        'A': {'B': 2, 'C': 1},
        'B': {'A': 2, 'C': 3, 'D': 4},
        'C': {'A': 1, 'B': 3, 'D': 2},
        'D': {'B': 4, 'C': 2}
    }
    resultado_custom_5 = dijkstra(grafo_5, 'D')
    nx_grafo_5 = nx.Graph(grafo_5)
    resultado_nx_5 = nx.single_source_dijkstra_path_length(nx_grafo_5, 'D')
    assert resultado_custom_5 == resultado_nx_5
    print("Teste 5 - Resultado Customizado:", resultado_custom_5)
    print("Teste 5 - Resultado Networkx:", resultado_nx_5)

if __name__ == '__main__':
    pytest.main(['-v', '-s'])

"""2) Faça a análise da complexidade algorítmica da solução em 1) para Big O, Big Theta e Big Omega. (2,00 pontos).

A complexidade algorítmica do algoritmo de Dijkstra pode ser analisada em termos de Big O, Big Theta e Big Omega, considerando o número de vértices (V) e o número de arestas (E) no grafo.

    Big O (O):
      A complexidade do algoritmo de Dijkstra é O((V + E) * log(V)).
      Isso se deve ao fato de que a operação de pop e push no heap (implementado por heapq) tem complexidade logarítmica e, no pior caso, o loop while executa V + E vezes.

    Big Theta (Θ):
      A complexidade do algoritmo é Θ((V + E) * log(V)).
      Isso implica que, no melhor caso e no pior caso, o algoritmo tem um desempenho assintótico semelhante.

    Big Omega (Ω):
      A complexidade inferior é, em geral, a mesma que a complexidade superior no caso do algoritmo de Dijkstra.
      Portanto, Ω((V + E) * log(V)).

3) Implemente uma solução em python para a Centralidade Eigenvector conforme descrito na semana 10 da disciplina. Implementar pelo menos 5 testes (pytest) validando sua implementação com uma função similar já feita no Networkx
"""

import networkx as nx
import pytest
import matplotlib.pyplot as plt

def eigenvector_centrality(graph):
    # Calcula a centralidade eigenvector do grafo
    return nx.eigenvector_centrality(graph)

def test_eigenvector_centrality():
    # Teste 1: Grafo pequeno
    g1 = nx.Graph()
    g1.add_edges_from([(1, 2), (1, 3), (2, 3)])
    centrality1 = eigenvector_centrality(g1)
    assert len(centrality1) == 3

    # Teste 2: Grafo direcionado
    g2 = nx.DiGraph()
    g2.add_edges_from([(1, 2), (2, 3), (3, 1)])
    centrality2 = eigenvector_centrality(g2)
    assert len(centrality2) == 3

    # Teste 3: Grafo vazio
    g3 = nx.Graph()
    centrality3 = eigenvector_centrality(g3)
    assert len(centrality3) == 0

    # Teste 4: Grafo completo
    g4 = nx.complete_graph(5)
    centrality4 = eigenvector_centrality(g4)
    assert len(centrality4) == 5

    # Teste 5: Grafo desconectado
    g5 = nx.Graph()
    g5.add_nodes_from([1, 2, 3])
    centrality5 = eigenvector_centrality(g5)
    assert len(centrality5) == 3

# Executa os testes
pytest.main()

# Visualização da Centralidade Eigenvector
def visualize_eigenvector_centrality(graph):
    fig, ax = plt.subplots(1, 1, figsize=(10, 8))
    pos = nx.spring_layout(graph, seed=123456789, k=0.3)
    color = list(dict(eigenvector_centrality(graph)).values())

    # Desenha as arestas
    nx.draw_networkx_edges(graph, pos=pos, alpha=0.4, ax=ax)
    # Desenha os nós
    nodes = nx.draw_networkx_nodes(graph, pos=pos, node_color=color, cmap=plt.cm.jet, ax=ax)
    # Desenha os rótulos
    nx.draw_networkx_labels(graph, pos=pos, font_color='white', ax=ax)

    plt.axis("off")
    plt.colorbar(nodes)
    plt.show()

# Exemplo de uso
g = nx.complete_graph(10)
visualize_eigenvector_centrality(g)