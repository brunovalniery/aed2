# -*- coding: utf-8 -*-
"""AED2-ShortestWay_n_AlgorithmicComplexity

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1P3Q0SCKvf_MtvntMhrL31yYDgoP0s1ep

1) Implementar em Python o algoritmo do caminho mais curto (Algoritmo de Dijkstra). Implementar pelo menos 5 testes (pytest) validando sua implementação com uma função similar já feita no Networkx. (4,00 pontos)
"""

pip install pytest networkx



import heapq
import networkx as nx
import pytest

class Grafo:
    def __init__(self):
        self.vertices = set()
        self.arestas = {}
        self.distancias = {}

    def adicionar_vertice(self, valor):
        self.vertices.add(valor)
        self.arestas[valor] = []

    def adicionar_aresta(self, de, para, distancia):
        self.arestas[de].append((para, distancia))
        self.arestas[para].append((de, distancia))

    def dijkstra(self, inicial):
        # Inicializar as distâncias como infinito para todos os vértices, exceto o inicial
        self.distancias = {vertice: float('infinity') for vertice in self.vertices}
        self.distancias[inicial] = 0

        # Usar uma fila de prioridade (heap) para armazenar os vértices a serem explorados
        fila_prioridade = [(0, inicial)]

        while fila_prioridade:
            # Extrair o vértice com a menor distância da fila de prioridade
            distancia_atual, vertice_atual = heapq.heappop(fila_prioridade)

            # Verificar as distâncias para os vizinhos do vértice atual
            for vizinho, peso in self.arestas[vertice_atual]:
                distancia_alternativa = distancia_atual + peso

                # Se a distância alternativa for menor, atualizar a distância
                if distancia_alternativa < self.distancias[vizinho]:
                    self.distancias[vizinho] = distancia_alternativa
                    heapq.heappush(fila_prioridade, (distancia_alternativa, vizinho))

        return self.distancias

# Exemplo de uso:
grafo = Grafo()

grafo.adicionar_vertice('A')
grafo.adicionar_vertice('B')
grafo.adicionar_vertice('C')
grafo.adicionar_vertice('D')
grafo.adicionar_vertice('E')

grafo.adicionar_aresta('A', 'B', 1)
grafo.adicionar_aresta('B', 'C', 2)
grafo.adicionar_aresta('A', 'D', 3)
grafo.adicionar_aresta('D', 'E', 1)
grafo.adicionar_aresta('B', 'E', 2)
grafo.adicionar_aresta('C', 'E', 4)

inicio = 'A'
distancias = grafo.dijkstra(inicio)

print(f'Distâncias a partir do vértice {inicio}: {distancias}')


@pytest.fixture
def example_graph():
    return {
        'A': {'B': 1, 'C': 4},
        'B': {'A': 1, 'C': 2, 'D': 5},
        'C': {'A': 4, 'B': 2, 'D': 1},
        'D': {'B': 5, 'C': 1}
    }

def test_dijkstra_implementation(example_graph):
    result_implementation = dijkstra(example_graph, 'A')

    # Utilizando Networkx para comparar os resultados
    G = nx.Graph(example_graph)
    result_networkx = nx.single_source_dijkstra_path_length(G, 'A')

    assert result_implementation == result_networkx

def test_dijkstra_disconnected_graph():
    # Grafo não conectado
    graph = {'A': {}, 'B': {}, 'C': {}}
    result_implementation = dijkstra(graph, 'A')

    # Utilizando Networkx para comparar os resultados
    G = nx.Graph(graph)
    result_networkx = nx.single_source_dijkstra_path_length(G, 'A')

    assert result_implementation == result_networkx

def test_dijkstra_directed_graph():
    # Grafo direcionado
    graph = {'A': {'B': 1, 'C': 4}, 'B': {'C': 2, 'D': 5}, 'C': {'D': 1}}
    result_implementation = dijkstra(graph, 'A')

    # Utilizando Networkx para comparar os resultados
    G = nx.DiGraph(graph)
    result_networkx = nx.single_source_dijkstra_path_length(G, 'A')

    assert result_implementation == result_networkx

def test_dijkstra_graph_with_negative_weights():
    # Grafo com pesos negativos
    graph = {'A': {'B': 1, 'C': -2}, 'B': {'C': 2, 'D': 5}, 'C': {'D': 1}}
    result_implementation = dijkstra(graph, 'A')

    # Utilizando Networkx para comparar os resultados
    G = nx.Graph(graph)
    result_networkx = nx.single_source_dijkstra_path_length(G, 'A')

    assert result_implementation == result_networkx

def test_dijkstra_empty_graph():
    # Grafo vazio
    graph = {}
    result_implementation = dijkstra(graph, 'A')

    # Utilizando Networkx para comparar os resultados
    G = nx.Graph(graph)
    result_networkx = nx.single_source_dijkstra_path_length(G, 'A')

    assert result_implementation == result_networkx

# Execute os testes
if __name__ == "__main__":
    pytest.main()



import heapq
import pytest
from networkx import Graph

def dijkstra(graph, source):
   nodes = {}
   for node in graph:
       nodes[node] = Node()
   nodes[source].d = 0
   queue = [(0, source)] # priority queue
   while queue:
       d, node = heapq.heappop(queue)
       if nodes[node].finished:
           continue
       nodes[node].finished = True
       for neighbor in graph[node]:
           if nodes[neighbor].finished:
               continue
           new_d = d + graph[node][neighbor]
           if new_d < nodes[neighbor].d:
               nodes[neighbor].d = new_d
               nodes[neighbor].parent = node
               heapq.heappush(queue, (new_d, neighbor))
   return nodes

# Cria um grafo de teste
g = Graph()
g.add_edge('A', 'B', weight=1)
g.add_edge('A', 'C', weight=4)
g.add_edge('B', 'D', weight=2)
g.add_edge('C', 'D', weight=1)
g.add_edge('C', 'F', weight=3)
g.add_edge('D', 'E', weight=8)
g.add_edge('F', 'C', weight=2)

# Testes
@pytest.mark.parametrize("start_node,expected", [
  ('A', {'A': 0, 'B': 1, 'C': 4, 'D': 5, 'E': 13, 'F': 7}),
  ('B', {'A': 1, 'B': 0, 'C': 3, 'D': 2, 'E': 10, 'F': 5}),
  ('C', {'A': 4, 'B': 3, 'C': 0, 'D': 1, 'E': 9, 'F': 3}),
  ('D', {'A': 5, 'B': 2, 'C': 1, 'D': 0, 'E': 8, 'F': 6}),
  ('E', {'A': 13, 'B': 10, 'C': 9, 'D': 8, 'E': 0, 'F': 11})
])

def test_dijkstra(start_node, expected):
  result = dijkstra(g, start_node)
  print(f"Testing with start node {start_node}:")
  print(f"Expected: {expected}")
  print(f"Result: {result}")
  assert result == expected

"""2) Faça a análise da complexidade algorítmica da solução em 1) para Big O, Big Theta e Big Omega. (2,00 pontos).

A complexidade algorítmica do algoritmo de Dijkstra pode ser analisada em termos de Big O, Big Theta e Big Omega, considerando o número de vértices (n) e o número de arestas (m) no grafo.

    Big O (O):
        No pior caso, o algoritmo de Dijkstra possui complexidade O((n + m) * log(n)) quando implementado com uma fila de prioridade usando um heap binário ou Fibonacci. Isso ocorre devido às operações de inserção/remoção no heap, que têm complexidade logarítmica em relação ao número de elementos.

    Big Theta (Θ):
        A complexidade média do Dijkstra também é O((n + m) * log(n)), portanto, Θ((n + m) * log(n)) é uma representação precisa do comportamento médio.

    Big Omega (Ω):
        Em um grafo denso, onde m é aproximadamente n^2, a complexidade do Dijkstra pode se aproximar de Ω(n^2). Isso ocorre porque, em cada iteração, ele precisa percorrer todos os vértices para encontrar o mínimo no heap. No entanto, para a maioria dos casos práticos, os grafos são esparsos, e a complexidade permanece dominada pelo fator logarítmico do heap.

"""