# -*- coding: utf-8 -*-
"""AED-II_F1Clash.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19LWdLKvMABAypnnZei82Ax4178juI-CK

# AED-II
## Objetivo Principal:
- Aplicar o conhecimento adquirido sobre grafos/redes na Semana 05 conforme detalhado em https://github.com/ivanovitchm/datastructure.

## Objetivos Secundários:

- Implementar o conhecimento da semana 5 no contexto apresentado do jogo F1 Clash.

- Utilizar como referência os elementos citados nos slides: componentes do veículo (cards), pontuação dos pilotos, e garrafinhas (boost).


##Tarefa 01 (slides 11 e 12): Pontuação: 1,00 ponto

- Criar um histograma para a métrica "Team Score" com as 262.144 combinações possíveis de configuração de veículo.

- Estabelecer um limite no histograma que reduza significativamente as configurações possíveis.

- O entregável será o código Python usado para criar o gráfico, similar ao apresentado no slide 12, junto com uma descrição do processo e a lógica para definir o filtro limitador para o "Team Score". Toda a explicação deverá estar no arquivo README.md do repositório no Github referente ao respectivo trabalho.

##Tarefa 02 (slide 13): Pontuação: 2,00 pontos

- Utilizar o filtro da Tarefa 01 e a biblioteca NetworkX para criar um gráfico similar ao apresentado no Slide 13.

- Escolher se o tamanho do vértice será proporcional ao "Team Score" (vértice vermelho) ou ao "Out Degree" dos cards (vértice preto).

- O entregável incluirá o código e a imagem do grafo. Na descrição, explicar as conclusões obtidas no contexto do jogo F1 Clash.

- Com o grafo do item anterior, criar um gráfico para a Função de Densidade de Probabilidade (PDF) da propriedade "Out Degree" dos vértices associados aos cards dos setups, usando além do NetworkX, a biblioteca Seaborn (KDE function). O entregável inclui o código e a explicação contextualizada para o jogo F1 Clash sobre o que o PDF do "Out Degree" revela.

##Tarefa 03 (slide 16): Pontuação: 1,00 ponto

- Criar um grafo bipartido para as garrafinhas do jogo F1 Clash e suas propriedades correspondentes, com dois grupos: Garrafinhas e Propriedades.

- O tamanho dos vértices das Propriedades será proporcional ao "Out Degree" dos vértices.

- O entregável incluirá o código para gerar o gráfico, a imagem do grafo e uma explicação contextualizando o resultado no jogo F1 Clash, utilizando a biblioteca nxviz para um layout circular similar ao Slide 16.



##Tarefa 04 (slide 18): Pontuação: 1,00 ponto

- Tarefa livre.

- Com base no conteúdo da Semana 05, e considerando a configuração final do jogo F1 Clash derivada das peças do carro, pilotos e garrafa, propor uma solução para auxiliar um jogador a escolher uma configuração específica.

- O entregável será o código desenvolvido, as imagens criadas e uma explicação com as principais conclusões.



##Observações Finais:

- O projeto pode ser realizado individualmente ou em dupla.

- O projeto terá uma pontuação correspondente a 5,00 pontos da Unidade 02.

- Apresentar o trabalho em um repositório no Github conforme descrito nas Tarefas 01, 02, 03 e 04, identificando todos os membros da equipe no arquivo README.

- Produzir um vídeo de até 5 minutos (preferencialmente no Loo) explicando de maneira geral o desenvolvimento, os principais resultados e conclusões.

- Ao submeter a tarefa, fornecer o link do repositório no campo descrição e anexar um arquivo .zip com todos os arquivos gerados. O arquivo .zip é apenas para registro; caso o projeto não esteja em um repositório do Github, a nota será zero.
"""

import matplotlib.pyplot as plt
import numpy as np
import itertools
# Gere valores aleatórios para cada componente com base nas faixas especificadas
speed = np.random.randint(1, 51, 262144)
cornering = np.random.randint(1, 51, 262144)
power_unit = np.random.randint(1, 51, 262144)
reliability = np.random.randint(1, 51, 262144)
average_pit_stop_time = np.random.uniform(0, 1, 262144)

# Calcule o Team Score para cada combinação
team_score = speed + cornering + power_unit + reliability + (average_pit_stop_time / 0.02)

#Lista com os valores da métrica "Team Score" para as 262.144 combinações.
#team_scores = [65, 78, 85, 90, 72, 79, 88, 72, 76, 91, 85, 70, 68, 78, 82, 76, 70, 84, 89, 95]

#Definação do número de bins para o histograma.
#Isso determina quantos intervalos serão usados para agrupar os dados.
num_bins = 20  # Ajuste esse valor conforme necessário

#Histograma usando a função plt.hist():
#team_scores: A lista de valores da métrica "Team Score".
#bins: O número de intervalos (bins) que você definiu anteriormente.
#color: A cor das barras do histograma.
#alpha: A transparência das barras.
plt.hist(team_score, bins=num_bins, color='blue', alpha=0.7)

#Rótulos e títulos ao histograma para torná-lo informativo:
plt.xlabel('Team Score')
plt.ylabel('Frequência')
plt.title('Histograma do Team Score')

#Exiba o histograma usando plt.show():
plt.show()

#---------
# Gere todas as combinações possíveis
combos = list(itertools.product(range(1, 7), repeat=9))

# Calcule o Team Score para cada combinação
scores = [calculate_team_score(combo) for combo in combos]

# Crie o histograma
plt.hist(scores, bins=50)

# Estabeleça um limite
limit = calculate_limit(scores)

"""Para realizar a Tarefa 02, os seguintes passos podem ser adotados:

1. **Filtragem**: Primeiro, aplicar o filtro da Tarefa 01 para reduzir o número de configurações possíveis.

2. **Criação do Grafo**: Em seguida, usar a biblioteca NetworkX para criar um grafo. Cada nó no grafo pode representar uma configuração de veículo, e as arestas podem representar alguma relação entre as configurações (por exemplo, duas configurações podem ser conectadas se diferirem por apenas um componente do veículo).

3. **Atribuição do Tamanho do Vértice**: Escolher se o tamanho do vértice será proporcional ao "Team Score" ou ao "Out Degree" dos cards. É possível realizar isso usando o argumento `node_size` na função `nx.draw`.

4. **Criação do PDF**: Finalmente, usar a biblioteca Seaborn para criar um gráfico da Função de Densidade de Probabilidade (PDF) do "Out Degree" dos vértices. É possível fazer isso usando a função `sns.kdeplot`.
"""

import networkx as nx
import seaborn as sns
#import matplotlib.pyplot as plt

# Crie o grafo
G = nx.Graph()

# Adicione nós e arestas ao grafo (substitua isso pelo seu próprio código)
for combo in filtered_combos:
    G.add_node(combo, team_score=calculate_team_score(combo))

# Escolha o tamanho do vértice
node_sizes = [G.nodes[combo]['team_score'] for combo in G.nodes]  # ou use o out degree

# Desenhe o grafo
nx.draw(G, node_size=node_sizes)

# Mostre o gráfico
plt.show()

# Crie o PDF
out_degrees = [G.degree[combo] for combo in G.nodes]
sns.kdeplot(out_degrees)

# Mostre o PDF
plt.show()